# Search Algorithms

Searching Algorithms are designed to check for an element or retrieve an element from any data structure where it is stored. Based on the type of search operation, these algorithms are generally classified into two categories:

- Sequential Search: In this, the list or array is traversed sequentially and every element is checked. For example: Linear Search.
- Interval Search: These algorithms are specifically designed for searching in sorted data-structures. These type of searching algorithms are much more efficient than Linear Search as they repeatedly target the center of the search structure and divide the search space in half. For Example: Binary Search.



- Depth First Search

- Breadth First Search

- Binary Search

## Weighted Search & Heuristics

### Heuristics:
Often times we need to estimate the cost or weight of an edge in a graph traversal problem. This can be done by using various types of heuristics, to estimate cost. More often than not, we also lack the exact cost of the path/total we wish to calculate, or the time to compute the exact value would be inefficient. Therefore, we implore various types of heuristics to approximate these values, which also saves us time. 

- Consistent vs. Admissible Heuristics:
  - Consistent Heuristic: For every node `n` and the successor, `n'` of `n`, generated by some action `a`, the estimated cost of reaching the goal from `n` is no greater than the step-cost from `n` to `n'` plus the estimated cost (heuristic) of reaching the goal from node `n'`.
  - Admissible Heuristic: if 0 <= `h(n)` <= `h*(n)`, where `h*(n)` is the true cost to reach the goal node. 
    - I.e., the heuristic does not ever overestimate the cost of reaching the goal.

- Any consistent heuristic is also admissible, but not the other way around!

- Common Types of Heuristic Approximations:
  - Manhattan Distance: Simply the sum of the absolute values of the difference in the current and target node coordinates. Used in situations that only allow N, E, S, W movements.
  - Diagonal Distance: The maximum of the absolute values of the differences in the current and target node's x and y coordinates. Used in situations that only allow movement in 8 directions, like a King in a chess game.
  - Euclidean Distance: Implied by its name, this heuristic approximates using the distance between the current and target cell by using the distance formula:
    - h = sqrt(current_node.x - goal.x)^2 + (current_node.y - goal.y)^2 )
    - Used in situations that allow movement in any direction, like a gps map.

### Dijkstra's Search Algorithm

### Astar Search
 
A* Search algorithm is one of the best and popular technique used in path-finding and graph traversals.

This algorithm is complete and optimal*
 
** IF the heuristic is admissible!

At each iteration, A* Search chooses the node according to a value `f` which is the sum of 2 other parameters, `g` and `h`. 
  - `g` = the cost to move from the start node to the current node, given the path that got us here
  - `h` = The estimated cost to get from the current node to the target node.

The Algorithm:
```
  1. Initialize our "frontier" (nodes to be explored)
  2. Initialize our explored set and insert the start node in the frontier (with f = 0)
  
  3. While the frontier is not empty:
      a) Find the node with the minimal `f` on the frontier and call it "q".
      
      b) Pop "q" off the frontier
      
      c) Generate all successors to "q" and set their parents to "q"
      
      d) For each successor: 
          i) If successor is the goal node, then stop search/
              - successor.g = q.g + distance between successor and q
              - successor.h = distance from the goal to the successor
              
              - successor.f = successor.g + successor.h
              
          ii) If a node with the same position as successor is in the frontier, but has a lower `f` than successor, then skip this successor
          
          iii) If a node with the same position as successor is in the explored set, but has a lower `f` than successor, then skip this successor. Otherwise, add the node to the frontier.
          
      [End for-loop]
      
       
      e) push q on the explored set
      
  [End while-loop]
```
